# About Dagger 2
This repo contains a basic code for learning Dagger 2.

## Basic Annotations

**(1) @Modules** - This annotation is used for the classes whose methods (not Constructor) provide the dependency to the Component Interface.

**(2) @Provides** - This annotation is used on methods of the Module-Annotated-Class, that provides the Dependency to the Component Interface.

```
@Module
class A {

@Provides
A getterForA() {
  return new A();
}

}
```

**(3) @Inject** - This annotation can be used on Variables (that will be injected either by Constructor or Method of respective class), and Constructors (that will be providing the dependency).
```
class B {

@Inject
public B() {}

}
```

**(4) @Component** - This annotated interface acts as a bridge between Dependancy and Dependent class. It provides objects from the dependant to the dependent class.

 **CASE 1)**
 ```
 @Component(modules = {A.class})
 interface ComponentClass {
 
 A getA();
 B getB();
   
 }
 ```
 **CASE 2)**
 ```
 @Component(modules = {A.class})
 interface ComponentClass {
 
 A getA();
 B getB();
   
 void inject(MainActivity mainActivity); 
 }
 ```

## Additional Annotations

**(1) @Includes**

**(2) @Scope**

**(3) @Named**

## Working

Now, lets complete our "Hello World" example for dagger,

**CASE 1) This is basic approach (please refer CASE 1 of ComponentClass, rest classes are same for it)**
 ``` 
 public class MainActivity extends AppCompatActivity {

    A a;
    B b;
    
    protected void onCreate(Bundle savedInstanceState) {
      //DaggerComponentClass is generated by Dagger 2
      ComponentClass component = new DaggerComponentClass.create(); 
      a = component.getA();
      b = component.getB();
      
      //use a,b
   }
}  
```
In this approach, we are manually writing initialisation code in `onCreate()` method. Although this approach has removed alots of Boilerplate Code. But still some initialisation needs to be done. We can remove it from by following Approach mentioned in Case 2.

**CASE 2) This is better approach and further removes boilerPlate Code (please refer CASE 2 of ComponentClass, rest classes are for it)**
```
 public class MainActivity extends AppCompatActivity {

    @Inject
    A a;
    
    @Inject
    B b;
    
    protected void onCreate(Bundle savedInstanceState) {
      //DaggerComponentClass is generated by Dagger 2
      DaggerComponentClass.inject(this);
      
      //use a,b 
   }
}  
 ```
 
In Case 2, of Component Class we have made a `void inject(MainActivity mainActivity)` method. Now, what Dagger does is find the void method, and come to know that there is something that it needs in the class, i.e. the fields annotated with @Inject and it will initialise them.
 
## Important Points

(1) The class generated by Dagger 2 is prefixed by 'Dagger' and then the name of the Component Interface.  
(2) Always `Rebuild` the Studio to make changes in the auto-generated Dagger-Component class.  
(3) Dagger is reflection free.  

## Contributor

[Saksham Handu](https://github.com/miPlodder)
